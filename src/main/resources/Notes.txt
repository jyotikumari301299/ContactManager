Question 1 - What is Dependency Injection and its Types?
Answer -Dependency Injection (DI) in Spring Boot is a design pattern that enables the creation of loosely coupled,
 testable, and maintainable code by allowing the framework to inject the required dependencies into a class, 
 rather than the class creating them itself. In essence, it inverts the control of object creation and dependency 
 management from the class to the Spring framework.
Here’s how Dependency Injection works in Spring Boot:

Inversion of Control (IoC):

The IoC principle is central to DI. It refers to the inversion of the flow of control in a program, 
where the framework (Spring) takes over the responsibility of instantiating and managing objects.

--->Types of Dependency Injection:
1)Constructor Injection: Dependencies are provided through a class constructor.
2)Setter Injection: Dependencies are provided through setter methods of a class.
3)Field Injection: Dependencies are directly injected into class fields using annotations

-------------------------------------------
Spring Boot Annotations for DI
@Autowired: Used to indicate the dependency to be injected by Spring's IoC container.
@Service: Used to mark a class as a service provider.
@Component: A generic stereotype for any Spring-managed component.
@Repository: A specialization of @Component for data access layers.
@Controller: Used to define a controller class in Spring MVC.
------------------------------------------
Benefits of Dependency Injection
Loose Coupling: Classes are not responsible for creating their dependencies, promoting loose coupling.
Easy Testing: Dependencies can be easily mocked or stubbed in unit tests.
Maintainability: Changes in dependency implementations require minimal changes in the dependent classes.
Configuration Flexibility: Dependencies can be configured externally, often via annotations or XML.

---------------------
@Bean annotation in Springboot
Bean Definition
Here’s a definition of beans in the Spring Framework documentation:

--In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container
 are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC 
 container.

 This definition is concise and gets to the point but fails to elaborate on an important element: the Spring IoC container. Let’s take a closer look to see what it is and the benefits it brings in.

3. Inversion of Control
Simply put, Inversion of Control (IoC) is a process in which an object defines its dependencies without
 creating them. This object delegates the job of constructing such dependencies to an IoC container.

Let’s start with the declaration of a couple of domain classes before diving into IoC.

3.1. Domain Classes
--Assume we have a class declaration:

        public class Company {
            private Address address;

            public Company(Address address) {
                this.address = address;
            }

            // getter, setter and other properties
        }

--This class needs a collaborator of type Address:

        public class Address {
            private String street;
            private int number;

            public Address(String street, int number) {
                this.street = street;
                this.number = number;
            }

            // getters and setters
        }

3.2. Traditional Approach
Normally, we create objects with their classes’ constructors:

        Address address = new Address("High Street", 1000);
        Company company = new Company(address);

There’s nothing wrong with this approach, but wouldn’t it be nice to manage the dependencies in a better way?

--Imagine an application with dozens or even hundreds of classes. Sometimes we want to share a single instance of a c
lass across the whole application, other times we need a separate object for each use case, and so on.

--Managing such a number of objects is nothing short of a nightmare. This is where inversion of control comes to 
the rescue.

--Instead of constructing dependencies by itself, an object can retrieve its dependencies from an IoC container.
 All we need to do is to provide the container with appropriate configuration metadata.

3.3. Bean Configuration
First off, let’s decorate the Company class with the @Component annotation:

        @Component
        public class Company {
            // this body is the same as before
        }

Here’s a configuration class supplying bean metadata to an IoC container:

        @Configuration
        @ComponentScan(basePackageClasses = Company.class)
        public class Config {
            @Bean
            public Address getAddress() {
                return new Address("High Street", 1000);
            }
        }

--The configuration class produces a bean of type Address. It also carries the @ComponentScan annotation, 
which instructs the container to look for beans in the package containing the Company class.

--When a Spring IoC container constructs objects of those types, all the objects are called Spring beans, 
as they are managed by the IoC container.

3.4. IoC in Action
--Since we defined beans in a configuration class, we’ll need an instance of the AnnotationConfigApplicationContext 
class to build up a container:

ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);

A quick test verifies the existence and the property values of our beans:

        Company company = context.getBean("company", Company.class);
        assertEquals("High Street", company.getAddress().getStreet());
        assertEquals(1000, company.getAddress().getNumber());

The result proves that the IoC container has created and initialized beans correctly.

4. Conclusion
This article gave a brief description of Spring beans and their relationship with an IoC container.
---------------------------


